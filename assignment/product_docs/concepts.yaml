Продукт: !concept
  определение: |
    Синонимы: Инструмент.
  Кодовая база сайта: !example |
    Кодовую базу сайта можно рассматривать как отдельный продукт. Пользуются им программисты, сис.админы, product-менеджеры и конечные пользователи.
  Веб-сервис: !example |
    Как продукт можно рассматривать веб-сервис целиком, включающий не только кодовую базу, но ещё сервера,
    маркетинг, контент, комьюнити в Telegram и пр.
  Отчёт о расследовании инцидента: !example |
    Как продукт можно рассматривать результат расследования причин сбоя в работе ПО. Это может быть отчёт по
    стандартной форме, включающий описание причин, как воспроизвести проблему, каков ущерб и что стоит предпринять.
  Отчёт о проведённом тестировании ПО: !example |
    Как продукт можно рассматривать результат проведённого тестирования ПО. Это может быть список протестированных
    историй, набор критических багов и отложенных issues.
  Подразделение компании: !example |
    Как продукт можно рассматривать подразделение компании целиком вместе с инструментами, орг.структурой,
    штатным расписанием и людьми. Бизнес-юнит является продуктом с точки зрения начальства, внешних и
    внутренних заказчиков. Продукт включает в себя и тех людей, что сейчас работают в этом подразделении.
  Продукт с подсистемами: !example


Польза: !concept
  определение: |
    Польза - это работа, на которую Пользователь "нанимает продукт". Польза по сути является Job Statement
    из фреймворка JTBD (см. ссылку в `referencies`). У пользователя есть задача, которую надо выполнить,
    и он ищет лучший продукт, инструмент, который поможет ему в этом.

    Синонимы: Желание, Хотелка, Проблема, Потребность
  Разные уровни пользы: !example |
    Уровни пользы: Поскольку Польза - это прежде всего ответ на вопрос "Зачем нужен продукт?",
    то вопрос этот можно задать многократно, перейдя от желания выполнить конкретное действия до эмоции или базовой
    потребности человека. Пример:

    ```
    --Пользователь 1--
    Хочу писать чистый код --> Зачем?
      Чтобы код выглядел профессионально --> Зачем?
        Чтобы показать свой код на собеседовании --> Зачем?
          Чтобы устроиться на работу программистом --> Зачем?
            Чтобы потом переехать из РФ  --> Зачем?
              Чтобы не бояться, что попаду в армию, если объявят общую мобилизацию в РФ
    ```

    Если польза написана на уровне эмоций, то количество продуктов, которые ее могут обеспечить крайне велико
    и валерьянка будет конкурентом за выполнение работы "не бояться". При этом размер той аудитории, что выберет
    ваш продукт может оказаться невелико — продукт проиграет конкурентам.

    ```
    --Пользователь 2--
    Хочу писать чистый код --> Зачем?
      Чтобы код выглядел профессионально --> Зачем?
        Чтобы показать свой код на собеседовании --> Зачем?
          Чтобы устроиться на работу программистом --> Зачем?
            Чтобы зарабатывать много денег -->
              Чтобы чувствовать себя "крутым" 
    ```

    До третьего уровня пользы у разных пользователей совпадали, а значит мы можем сделать продукт для обоих пользователей,
    выделив пользу именно на уровне выполнения работы "устроиться на работу" и при этом предложить ему не только
    навык чистого кода, но и другие инструменты, которые помогут достичь желаемого.

    Навык написания чистого кода без более глубокой мотивации "устроиться на работу"" при этом не имеет ценности сам по
    себе. Поэтому описание пользы на столь высоком уровне приведет к раздуванию бюджета и добавлению малоэффективных
    историй. А значит снизит качество продукта, ведь важного результата пользователь не достигнет и продуктом
    пользоваться не станет.

    Задача выбора уровня пользы лежит на product manager и от выбранного решения зависит выживание продукта.
    Ищите золотую середину.
  human-machine agnostic: !example |
    Может описывать как работу человека, так и автомата.


Ситуация: !concept
  определение: |
    Описание обстоятельств, при которых у Пользователя возникает проблема или потребность. Отвечает на вопросы
    "Где?", "Когда?", "При каких обстоятельствах?". Сам по себе продукт не имеет ценности, но приобретает её, когда
    мы используем его в подходящей ситуации.

    Ситуация должна так описываться, чтобы её можно было воспроизвести в ходе тестирования продукта. Чем легче её
    вопроизвести -- тем лучше.
  На бегу: !example |
    Проблемы возникают у пользователя в определенных ситуациях: место, время, внешние условия, взаимодействие с другими людьми. Добавьте контекст в пользу верхнего уровня, чтобы обозначить в каких ситуациях пользователю понадобится продукт. Например, если продуктом будут пользоваться "на бегу", то нет смысла делать MVP для десктопа.
  Описание персоны: !exclusion |
    В UX дизайне есть такое понятие, как "Персона". Она состоит из многих элементов - имя, место работы и
    должность, демографические характеристики, технический бэкграунд, высказывание, фотографии/картинки персоны.
    Цель персон — создать эмпатию у команды, особенно у тех, кто не общается с пользователями. Во фреймворках
    JTBD и Product Flow фокус с персональных характеристик смещается на мотивацию и описание ситуации. Мать троих
    детей, живущая в Америке, выкладывает фотографии в социальную сеть по тем же причинам и в похожих ситуациях, что
    и корейский подросток.

    Ситуация -- это не описание персоны.
  Внутреннее состояние продукта: !example |
    Например: особое наполнение БД сайта, сетевая доступность сервисов, нагрузка на веб-сервис.
  Внутреннее состояние роли: !example |
    Например: привычка, желание, эмоциональное состояние, физическое состояние.
  Наличие ресурсов: !example |
    Например, это может быть наличие или отстутствие необходимого инструмента, помощника, времени, денег.


Точка старта: !concept
  определение: |
    Место, откуда пользователь начинает своё взаимодействие с продуктом, например "открыл страницу сайта".


Роль: !concept
  определение: |
    Роль можно рассматривать -- как повторяющийся элемент ситуации, работающий для всех функций разом.
    Способ один раз описать роль с её  воспроизводимые фальсифицируемые условия тестирования
    вместо того, чтобы копипастить их раз за разом.
  # TODO Важна возможность быстро поставить себя на место этой роли. Это полезно, хотя и не обязательно. Иногда
  # для качественного тестирования необходимо привлекать людей, привычных к нужной роли.

  # FIXME Может ли пользователем быть неживой продукт ? Пример с сервисом мониторинга или поисковым роботом.

  # FIXME Может ли пользователем быть неявный выгодополучатель?
    # Возможна ли польза без непосредственного взаимодействия с продуктом или исключена?
    # Заказчик разработки продукта может не пользоваться продуктом напрямую, но разве он не хочет получить прибыль
    # от продажи продукта? А может, Исполнителю нужен крутой продукт для прокачки личного бренда, а не просто
    # вознаграждение за проект? Пользу могут получать разные Роли и их интересы не менее важны, чем интересы конечного
    # Пользователя. Например, задача получения прибыли добавит в продукт платную подписку, наличие которой никак
    # не вытекает из пользы для Пользователя.


История: !concept
  определение: |
    История (Job story) — это быстрый способ документировать требования клиента, без необходимости разрабатывать
    обширные формализованные документы и впоследствии тратить ресурсы на их поддержание.

    Одним и тем же продуктом можно воспользоваться по-разному. Истории фиксируют не все способы использования, а только
    самые популярные и важные -- те, что достойны учёта и отладки.

    ## История vs Алгоритм действий

    Пользовательский интерфейс сайта, чат-бота и подобных IT-систем по природе своей асинхронен и нелинейнен.
    Даже чат-бот, несмотря на свою нелинейность, всегда позволяет вернуться на предыдущий шаг или в главное меню,
    чтобы начать с начала. Действия пользователя имеет смысл рассматривать как итеративный нелинейный процесс.
    На самом деле, большую часть реального полного "алгоритма действий пользователя" составляет не основной поток,
    а альтернативные потоки, которые позволяют задавать ветвления потока, циклы и обрабатывать «неправильные» события.

    Корень проблемы здесь в концепциях "алгоритма действий", "бизнес-процесса", "сценария использования". Мы
    описываем работу системы человек-машина как детерминированный последовательный процесс. Но на деле всё, что
    легко свести к линейному процессу так же легко поддаётся полной автоматизации. Люди остаются лишь в тех
    бизнес-процессах, где важна нелинейность. Поэтому описывать взаимодействие человека с машиной как линейный процесс
    нельзя. Взаимодействие вариативно, изменчиво, зависит от состояния системы, желания разных людей и их возможностей.

    Поэтому в Истории нет "алгоритма действий". Есть действующее лицо (роль) c его желанием, есть начало пути
    пользователи и конец, но отсутствует "серединка".

    Истории используются в UX тестировании по аналогии с автотестами из программирования.

    Синонимы: Job story.
  Реализованная история: !example |
    Историю считаем реализованной, если вероятность успешного выполнения работы пользователем продукта достаточно высока.

    Реализована история или нет -- это субъективная метрика. Другой менеджер продукта может забраковать историю, которую ранее
    протестировал и принял другой менеджер.
  Непроверяемая история: !exclusion |
    Важное свойство истории -- это возможность проверить выполнима заявленная работа с помощью продукта или нет.
  Одна история — две роли: !exclusion |
    Может так получится, что разные роли получат одну и ту же пользу от продукта. При этом разные роли
    подразумевают разную мотивацию и разные контексты, а значит, почти наверняка, пользоваться продуктом они
    будут по-разному.
  Точка расширения функциональности: !example
  Объективна в пределе: !example |
    Описание истории может давать ненадёжные результаты тестирования из-за влияния неучтённых обстоятельств. В таком случае
    раз от раза приёмочные тесты будут давать разные результаты -- то история выглядит реализованной, то нет.

    Не бывает на 100% объективных и точных историй. Но ожидаем, что по мере отладки продукта истории будут постепенно уточняться,
    что в пределе позволит добиться объективных результатов тестирования.

    Если с первого раза не смогли объективно доказать, что выполненная работа
    здесь была ни при чём, то может получиться со второй или третьей
    попытки если иначе провести приёмку.
  Отлаживаема в пределе: !example |
    Например, если стоит задача "сделать прототип бомбы". Взорвётся такая бомба или нет проверить мы можем только косвенными
    методами, но, если проявить должное упорство, то вероятность успешных испытаний можно сколь угодно далеко приблизить к 100%.

    Другой пример -- выпечка пирожков. Я могу проверить, получился ли на выходе пирожок, но съесть его два раза нельзя.
    Некоторые варианты использования/истории оказываются лишь частично отлаживаемыми.
    Можно ввести стандартный набор требований к пирожкам и свериться с ним.
    Можно протестировать фрагменты истории: "понюхать", "поместить в рот" и пр.
    Но нельзя протестировать всю историю целиком "Съесть пирожок", потому что тогда
    пирожка не станет.


Функция: !concept
  Внешняя функция: !example |
    Два уровня пользы в задании:
    О границах продукта нужно помнить во время проектирования и разработки, чтобы не терять "курс".
    Границы продукта точно будут на лендинге продукта самым крупным шрифтом. Именно за счет них Пользователь
    готов попробовать новый продукт.

    Синонимы: Граница продукта, Boundary, Ключевая функция.


Задание: !concept
  определение: |
    Задание на продукт — это описание, выполненное по стандартному шаблону. Совмещает в себе ТЗ, план работ и
    отчёт о проделанной работе.
  # TODO несколько альтернативных форматов, не только yaml

#TODO Добавить концепцию триггера Trigger
# Триггер -- это событие, которое случается "снаружи" продукта и приводит к возникновению желания воспользоваться
# продуктом. Отслеживать триггеры важно, когды мы боремся за удержание пользователя. Для удержания необходимо
# встроить продукт в рутины пользователя. Как это работает подробно описано в книге [Hooked. На крючке](https://www.litres.ru/book/nir-eyal/hooked-na-kruchke-kak-sozdavat-produkty-formiruuschie-privychki-7906348/)
# Триггеры важно отслеживать не всегда и не для всех продуктов
# ? Триггер может существовать как у внешней функции, так и у внутренней. Может привести к путанице, потому что для внутренних
# функций триггером, как правило, выступают внешние функции.
# ? Триггером может выступать цепочка событий?
# ? У одной истории может быть несколько альтернативных триггеров?
# ? Где пролегает граница между триггером и ситуацией ?

#TODO Добавить концепцию Reference внутрь функций и/или историй
# Reference может существовать как у внешней функции, так и у внутренней

#TODO Добавить концепцию Competitor внутрь функций и/или историй
# Только для func-export ? Почему внутренние функции продукта не могут конкурировать между собой ?
# Добавление конкурентов приведёт к распуханию задания? Захочется добавить матрицу конкурентного анализа,
# гипотеза о конкурентном преимуществе и сегментах? Кажется, что сами преимущества должны быть представлены в виде историй.

#TODO Добавить поддержку тегов для функций и историй

#TODO Добавить характерный контекст -- чтобы не копипастить каждый раз гору текста. Или тут достаточно будет yaml alias ?

Акцептор действия: !concept
  определение: |
    Гарантирует, что история фальсифицируема.
  Успех: !example
  Отказ: !example
  Акцептор ≠ условие окончания работы: !example |
    Пример акцептора без условия окончания: "Увижу в tg-канале опубликованную фотку до конца следующего дня". Проверить,
    что автопостинг по расписанию сломался можно, но когда постинг закончится — не указано.

# TODO Добавить концепцию "Сегмент" https://gist.github.com/pelid/e885177e9a0111c2205aa838788bfab7

# TODO Встроить в описание концепций иллюстрации для быстрого понимания.
